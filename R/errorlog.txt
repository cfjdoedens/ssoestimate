Duration: 41.4s

❯ checking examples ... ERROR
  Running examples in ‘ssoestimate-Ex.R’ failed
  The error most likely occurred in:

  > base::assign(".ptime", proc.time(), pos = "CheckExEnv")
  > ### Name: SSO_estimate
  > ### Title: Estimation of error fraction in SSO and client.
  > ### Aliases: SSO_estimate
  >
  > ### ** Examples
  >
  > x <- SSO_estimate(k_SSO = 1, n_SSO = 3000, N_client = 500, S = 2)
   ----------- FAILURE REPORT --------------
   --- failure: length > 1 in coercion to logical ---
   --- srcref ---
  :
   --- package (from environment) ---
  ssoestimate
   --- call from context ---
  dbinom_continuous(k_SSO, n_SSO, dim_P)
   --- call from argument ---
  (p == 0) && (k == 0)
   --- R stacktrace ---
  where 1: dbinom_continuous(k_SSO, n_SSO, dim_P)
  where 2: SSO_estimate(k_SSO = 1, n_SSO = 3000, N_client = 500, S = 2)

   --- value of length: 2 type: logical ---
  [1] FALSE FALSE
   --- function from context ---
  function (k, n, p, log = FALSE)
  {
      if (length(k) > 1) {
          return(map_dbl(k, dbinom_continuous, n, p))
      }
      stopifnot(0 <= k, k <= n)
      stopifnot(0 < n)
      stopifnot(0 <= p, p <= 1)
      if ((p == 0) && (k == 0)) {
          return(1)
      }
      if ((p == 0) && (k > 0)) {
          return(0)
      }
      if ((p == 1) && (k == n)) {
          return(1)
      }
      if ((p == 1) && (k < n)) {
          return(0)
      }
      beta_part <- lgamma(n + 1) - lgamma(k + 1) - lgamma(n - k +
          1)
      stopifnot(!is.nan(beta_part))
      prob_part <- k * log(p) + (n - k) * log(1 - p)
      stopifnot(!is.nan(prob_part))
      r <- beta_part + prob_part
      if (!log) {
          r <- exp(r)
      }
      stopifnot(!is.nan(r))
      r
  }
  <bytecode: 0x5d3e4c830bb8>
  <environment: namespace:ssoestimate>
   --- function search by body ---
  Function dbinom_continuous in namespace ssoestimate has this body.
   ----------- END OF FAILURE REPORT --------------
  Error in (p == 0) && (k == 0) :
    'length(x) = 2 > 1' in coercion to 'logical(1)'
  Calls: SSO_estimate -> dbinom_continuous
  Execution halted

❯ checking tests ...
  See below...

── Test failures ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── testthat ────

> # This file is part of the standard setup for testthat.
> # It is recommended that you do not modify it.
> #
> # Where should you do additional test configuration?
> # Learn more about the roles of various files in:
> # * https://r-pkgs.org/testing-design.html#sec-tests-files-overview
> # * https://testthat.r-lib.org/articles/special-files.html
>
> library(testthat)
> library(ssoestimate)
>
> test_check("ssoestimate")
 ----------- FAILURE REPORT --------------
 --- failure: length > 1 in coercion to logical ---
 --- srcref ---
:
 --- package (from environment) ---
ssoestimate
 --- call from context ---
dbinom_continuous(k_SSO, n_SSO, dim_P)
 --- call from argument ---
(p == 0) && (k == 0)
 --- R stacktrace ---
where 1: dbinom_continuous(k_SSO, n_SSO, dim_P)
where 2: SSO_estimate(k_SSO = 350, n_SSO = 350, N_client = 1000, S = 3)
where 3: eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
where 4: withVisible(code)
where 5: withCallingHandlers(withVisible(code), warning = handle_warning,
    message = handle_message)
where 6: force(code)
where 7: withr::with_output_sink(path, withCallingHandlers(withVisible(code),
    warning = handle_warning, message = handle_message))
where 8: .capture(act$val <- eval_bare(quo_get_expr(.quo), quo_get_env(.quo)),
    ...)
where 9: quasi_capture(enquo(object), NULL, evaluate_promise)
where 10 at test-ssoestimate.R#16: expect_silent(x <- SSO_estimate(k_SSO = 350, n_SSO = 350, N_client = 1000,
    S = 3))
where 11: eval(code, test_env)
where 12: eval(code, test_env)
where 13: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error)
where 14: doTryCatch(return(expr), name, parentenv, handler)
where 15: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 16: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 17: doTryCatch(return(expr), name, parentenv, handler)
where 18: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),
    names[nh], parentenv, handlers[[nh]])
where 19: tryCatchList(expr, classes, parentenv, handlers)
where 20: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error), error = handle_fatal,
    skip = function(e) {
    })
where 21: test_code(desc, code, env = parent.frame(), default_reporter = local_interactive_reporter())
where 22 at test-ssoestimate.R#15: test_that("Is bug still present?: client_min <= client_max is not TRUE",
    {
        expect_silent(x <- SSO_estimate(k_SSO = 350, n_SSO = 350,
            N_client = 1000, S = 3))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
    })
where 23: eval(code, test_env)
where 24: eval(code, test_env)
where 25: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error)
where 26: doTryCatch(return(expr), name, parentenv, handler)
where 27: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 28: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 29: doTryCatch(return(expr), name, parentenv, handler)
where 30: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),
    names[nh], parentenv, handlers[[nh]])
where 31: tryCatchList(expr, classes, parentenv, handlers)
where 32: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error), error = handle_fatal,
    skip = function(e) {
    })
where 33: test_code(test = NULL, code = exprs, env = env, default_reporter = StopReporter$new())
where 34: source_file(path, env = env(env), desc = desc, error_call = error_call)
where 35: FUN(X[[i]], ...)
where 36: lapply(test_paths, test_one_file, env = env, desc = desc, error_call = error_call)
where 37: doTryCatch(return(expr), name, parentenv, handler)
where 38: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 39: tryCatchList(expr, classes, parentenv, handlers)
where 40: tryCatch(code, testthat_abort_reporter = function(cnd) {
    cat(conditionMessage(cnd), "\n")
    NULL
})
where 41: with_reporter(reporters$multi, lapply(test_paths, test_one_file,
    env = env, desc = desc, error_call = error_call))
where 42: test_files_serial(test_dir = test_dir, test_package = test_package,
    test_paths = test_paths, load_helpers = load_helpers, reporter = reporter,
    env = env, stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,
    desc = desc, load_package = load_package, error_call = error_call)
where 43: test_files(test_dir = path, test_paths = test_paths, test_package = package,
    reporter = reporter, load_helpers = load_helpers, env = env,
    stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,
    load_package = load_package, parallel = parallel)
where 44: test_dir("testthat", package = package, reporter = reporter,
    ..., load_package = "installed")
where 45: test_check("ssoestimate")

 --- value of length: 3 type: logical ---
[1] FALSE FALSE FALSE
 --- function from context ---
function (k, n, p, log = FALSE)
{
    if (length(k) > 1) {
        return(map_dbl(k, dbinom_continuous, n, p))
    }
    stopifnot(0 <= k, k <= n)
    stopifnot(0 < n)
    stopifnot(0 <= p, p <= 1)
    if ((p == 0) && (k == 0)) {
        return(1)
    }
    if ((p == 0) && (k > 0)) {
        return(0)
    }
    if ((p == 1) && (k == n)) {
        return(1)
    }
    if ((p == 1) && (k < n)) {
        return(0)
    }
    beta_part <- lgamma(n + 1) - lgamma(k + 1) - lgamma(n - k +
        1)
    stopifnot(!is.nan(beta_part))
    prob_part <- k * log(p) + (n - k) * log(1 - p)
    stopifnot(!is.nan(prob_part))
    r <- beta_part + prob_part
    if (!log) {
        r <- exp(r)
    }
    stopifnot(!is.nan(r))
    r
}
<bytecode: 0x5b9c367d3ca0>
<environment: namespace:ssoestimate>
 --- function search by body ---
Function dbinom_continuous in namespace ssoestimate has this body.
 ----------- END OF FAILURE REPORT --------------
 ----------- FAILURE REPORT --------------
 --- failure: length > 1 in coercion to logical ---
 --- srcref ---
:
 --- package (from environment) ---
ssoestimate
 --- call from context ---
dbinom_continuous(k_SSO, n_SSO, dim_P)
 --- call from argument ---
(p == 0) && (k == 0)
 --- R stacktrace ---
where 1: dbinom_continuous(k_SSO, n_SSO, dim_P)
where 2: SSO_estimate(k_SSO = 0, n_SSO = 350, N_client = 1000, S = 2)
where 3: eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
where 4: withVisible(code)
where 5: withCallingHandlers(withVisible(code), warning = handle_warning,
    message = handle_message)
where 6: force(code)
where 7: withr::with_output_sink(path, withCallingHandlers(withVisible(code),
    warning = handle_warning, message = handle_message))
where 8: .capture(act$val <- eval_bare(quo_get_expr(.quo), quo_get_env(.quo)),
    ...)
where 9: quasi_capture(enquo(object), NULL, evaluate_promise)
where 10 at test-ssoestimate.R#47: expect_silent(x <- SSO_estimate(k_SSO = 0, n_SSO = 350, N_client = 1000,
    S = 2))
where 11: eval(code, test_env)
where 12: eval(code, test_env)
where 13: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error)
where 14: doTryCatch(return(expr), name, parentenv, handler)
where 15: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 16: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 17: doTryCatch(return(expr), name, parentenv, handler)
where 18: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),
    names[nh], parentenv, handlers[[nh]])
where 19: tryCatchList(expr, classes, parentenv, handlers)
where 20: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error), error = handle_fatal,
    skip = function(e) {
    })
where 21: test_code(desc, code, env = parent.frame(), default_reporter = local_interactive_reporter())
where 22 at test-ssoestimate.R#37: test_that("SSO_estimate() should still function with small values for S",
    {
        expect_silent(x <- SSO_estimate(k_SSO = 0, n_SSO = 350,
            N_client = 1000, S = 1))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 0, n_SSO = 350,
            N_client = 1000, S = 2))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 0, n_SSO = 350,
            N_client = 1000, S = 3))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 1, n_SSO = 350,
            N_client = 1000, S = 1))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 1, n_SSO = 350,
            N_client = 1000, S = 2))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 1, n_SSO = 350,
            N_client = 1000, S = 3))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 350, n_SSO = 350,
            N_client = 1000, S = 1))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 350, n_SSO = 350,
            N_client = 1000, S = 2))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
        expect_silent(x <- SSO_estimate(k_SSO = 350, n_SSO = 350,
            N_client = 1000, S = 3))
        expect_silent(y <- SSO_graph_plot(x, visual = FALSE))
        expect_silent(y <- SSO_graph_plot(x, visual = TRUE))
    })
where 23: eval(code, test_env)
where 24: eval(code, test_env)
where 25: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error)
where 26: doTryCatch(return(expr), name, parentenv, handler)
where 27: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 28: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 29: doTryCatch(return(expr), name, parentenv, handler)
where 30: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),
    names[nh], parentenv, handlers[[nh]])
where 31: tryCatchList(expr, classes, parentenv, handlers)
where 32: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,
    message = handle_message, error = handle_error), error = handle_fatal,
    skip = function(e) {
    })
where 33: test_code(test = NULL, code = exprs, env = env, default_reporter = StopReporter$new())
where 34: source_file(path, env = env(env), desc = desc, error_call = error_call)
where 35: FUN(X[[i]], ...)
where 36: lapply(test_paths, test_one_file, env = env, desc = desc, error_call = error_call)
where 37: doTryCatch(return(expr), name, parentenv, handler)
where 38: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 39: tryCatchList(expr, classes, parentenv, handlers)
where 40: tryCatch(code, testthat_abort_reporter = function(cnd) {
    cat(conditionMessage(cnd), "\n")
    NULL
})
where 41: with_reporter(reporters$multi, lapply(test_paths, test_one_file,
    env = env, desc = desc, error_call = error_call))
where 42: test_files_serial(test_dir = test_dir, test_package = test_package,
    test_paths = test_paths, load_helpers = load_helpers, reporter = reporter,
    env = env, stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,
    desc = desc, load_package = load_package, error_call = error_call)
where 43: test_files(test_dir = path, test_paths = test_paths, test_package = package,
    reporter = reporter, load_helpers = load_helpers, env = env,
    stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,
    load_package = load_package, parallel = parallel)
where 44: test_dir("testthat", package = package, reporter = reporter,
    ..., load_package = "installed")
where 45: test_check("ssoestimate")

 --- value of length: 2 type: logical ---
[1] FALSE FALSE
 --- function from context ---
function (k, n, p, log = FALSE)
{
    if (length(k) > 1) {
        return(map_dbl(k, dbinom_continuous, n, p))
    }
    stopifnot(0 <= k, k <= n)
    stopifnot(0 < n)
    stopifnot(0 <= p, p <= 1)
    if ((p == 0) && (k == 0)) {
        return(1)
    }
    if ((p == 0) && (k > 0)) {
        return(0)
    }
    if ((p == 1) && (k == n)) {
        return(1)
    }
    if ((p == 1) && (k < n)) {
        return(0)
    }
    beta_part <- lgamma(n + 1) - lgamma(k + 1) - lgamma(n - k +
        1)
    stopifnot(!is.nan(beta_part))
    prob_part <- k * log(p) + (n - k) * log(1 - p)
    stopifnot(!is.nan(prob_part))
    r <- beta_part + prob_part
    if (!log) {
        r <- exp(r)
    }
    stopifnot(!is.nan(r))
    r
}
<bytecode: 0x5b9c367d3ca0>
<environment: namespace:ssoestimate>
 --- function search by body ---
Function dbinom_continuous in namespace ssoestimate has this body.
 ----------- END OF FAILURE REPORT --------------
[ FAIL 2 | WARN 0 | SKIP 0 | PASS 30609 ]

══ Failed tests ════════════════════════════════════════════════════════════════
── Error ('test-ssoestimate.R:16:3'): Is bug still present?: client_min <= client_max is not TRUE ──
Error in `(p == 0) && (k == 0)`: 'length(x) = 3 > 1' in coercion to 'logical(1)'
Backtrace:
     ▆
  1. ├─testthat::expect_silent(...) at test-ssoestimate.R:16:3
  2. │ └─testthat:::quasi_capture(enquo(object), NULL, evaluate_promise)
  3. │   ├─testthat (local) .capture(...)
  4. │   │ ├─withr::with_output_sink(...)
  5. │   │ │ └─base::force(code)
  6. │   │ ├─base::withCallingHandlers(...)
  7. │   │ └─base::withVisible(code)
  8. │   └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
  9. └─ssoestimate::SSO_estimate(...)
 10.   └─ssoestimate:::dbinom_continuous(k_SSO, n_SSO, dim_P)
── Error ('test-ssoestimate.R:47:3'): SSO_estimate() should still function with small values for S ──
Error in `(p == 0) && (k == 0)`: 'length(x) = 2 > 1' in coercion to 'logical(1)'
Backtrace:
     ▆
  1. ├─testthat::expect_silent(...) at test-ssoestimate.R:47:3
  2. │ └─testthat:::quasi_capture(enquo(object), NULL, evaluate_promise)
  3. │   ├─testthat (local) .capture(...)
  4. │   │ ├─withr::with_output_sink(...)
  5. │   │ │ └─base::force(code)
  6. │   │ ├─base::withCallingHandlers(...)
  7. │   │ └─base::withVisible(code)
  8. │   └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo))
  9. └─ssoestimate::SSO_estimate(...)
 10.   └─ssoestimate:::dbinom_continuous(k_SSO, n_SSO, dim_P)

[ FAIL 2 | WARN 0 | SKIP 0 | PASS 30609 ]
Error: Test failures
Execution halted

2 errors ✖ | 0 warnings ✔ | 0 notes ✔
Error: R CMD check found ERRORs
Execution halted

Exited with status 1.
